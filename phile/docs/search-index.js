var searchIndex = {};
searchIndex["phile"] = {"doc":"This library provides the programmatic interface for the PHiLe Compiler and Domain-Specific Language. The crate is composed of several modules, each of which roughly corresponds to a single step in the compilation pipeline:","items":[[0,"util","phile","The `util` module provides various useful helper functions, types and macros, used extensively throughout the PHiLe source tree. Generic reference-counted smart pointers, string manipulation specific to the syntax of PHiLe, and commonly-used constants are all part of this file.",null,null],[3,"PackageInfo","phile::util","Type of a global descriptor that holds information about the current version of the PHiLe package (library and compiler). The purpose of a global instance of this struct is to provide user-readable version information in a uniform manner throughout the code base, and for potential 3rd-party tooling.",null,null],[12,"name","","The name of the PHiLe package.",0,null],[12,"version","","The version of the PHiLe package.",0,null],[12,"authors","","The list of authors of PHiLe.",0,null],[12,"description","","A short summary of this package.",0,null],[12,"home_page","","URL of the PHiLe home page.",0,null],[3,"Color","","A struct that contains escape sequences for ANSI terminal color codes. This is used for maintaining a uniform and consistent color scheme across diagnostic messages printed by the PHiLe compiler and 3rd-party tools.",null,null],[12,"reset","","ANSI escape sequence for resetting all color settings.",1,null],[12,"info","","ANSI escape sequence for displaying informative messages.",1,null],[12,"highlight","","ANSI escape sequence for displaying highlighted messages.",1,null],[12,"success","","ANSI escape sequence for indicating successful compilation.",1,null],[12,"error","","ANSI escape sequence for reporting errors.",1,null],[3,"RcCell","","A reference counted, dynamically borrow checked smart pointer. Like `Rc<RefCell<T>>`, but with a more convenient interface.",null,null],[3,"WkCell","","Weak counterpart of `RcCell<T>`.",null,null],[5,"grapheme_count","","Returns the number of extended grapheme clusters in `string`. Useful for counting 'characters' in accordance with a user's notion of a 'character' or grapheme. Mainly used by the lexer for generating visually accurate source location data.",null,{"inputs":[{"name":"str"}],"output":{"name":"usize"}}],[5,"grapheme_count_by","","Counts the grapheme clusters in a string that satisfy a condition.",null,{"inputs":[{"name":"str"},{"name":"p"}],"output":{"name":"usize"}}],[7,"PACKAGE_INFO","","Holds metadata about the PHiLe package as defined in the Cargo manifest.",null,null],[7,"COLOR","","The definition of the PHiLe diagnostic color scheme.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"packageinfo"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"color"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"rccell"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates an `RcCell` owning the `value`.",2,{"inputs":[{"name":"t"}],"output":{"name":"rccell"}}],[11,"borrow","","Attempts to immutably borrow the pointed value.",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"borrow_mut","","Attempts to mutably borrow the pointed value.",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_weak","","Converts the strong pointer to a weak pointer.",2,{"inputs":[{"name":"self"}],"output":{"name":"wkcell"}}],[11,"strong_count","","Returns the number of strong pointers pointing to the inner value.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"weak_count","","Returns the number of weak pointers pointing to the inner value.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"rccell"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"hash","","",2,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",2,{"inputs":[{"name":"t"}],"output":{"name":"rccell"}}],[11,"new","","Creates a `WkCell` that doesn't refer to any value. `as_rc()` will always return an `Err` for such `WkCell`s.",3,{"inputs":[],"output":{"name":"wkcell"}}],[11,"as_rc","","Converts a weak pointer to a strong pointer if possible.",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"wkcell"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"wkcell"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"error","phile","This module defines types for representing possible errors that may be generated during the compilation of some PHiLe source code. It also provides useful macros for reporting errors in a way that is consistent across modules.",null,null],[4,"Error","phile::error","An error that may occur while compiling PHiLe source code. This can be either a user-induced error (e.g. syntax error), or an Internal Compiler Error (abbreviated ICE), i.e. a bug. TODO(H2CO3): storing a stacktrace at the point of the failed borrow, strongification, or unreachable code would be nice.",null,null],[13,"IO","","I/O error, probably coming from the OS, not PHiLe itself",4,null],[13,"Borrow","","An immutable dynamic borrow failed. ICE.",4,null],[13,"BorrowMut","","A mutable dynamic borrow failed. ICE.",4,null],[13,"Strongify","","Converting a weak pointer to a strong one failed. ICE.",4,null],[13,"Unreachable","","Some unreachable code was reached as a result of a bug/unforeseen condition. ICE.",4,null],[12,"message","phile::error::Error","Description of the bug.",4,null],[12,"file","","Source file inside the PHiLe compiler that caused the bug.",4,null],[12,"line","","Source line index within the offending file.",4,null],[13,"Syntax","phile::error","A syntactic error was found in the source code.",4,null],[12,"message","phile::error::Error","Description of the syntax error.",4,null],[12,"range","","If available, the human-readable source range associated with the error. End-of-input is represented as `None`.",4,null],[13,"Semantic","phile::error","A semantic error was found in the source code.",4,null],[12,"message","phile::error::Error","Description of the semantic error.",4,null],[12,"range","","If available, the human-readable source range associated with the error. End-of-input is represented as `None`.",4,null],[6,"Result","phile::error","Convenience type alias for expressing `Result`s of PHiLe `Error`s.",null,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"pretty_print","","Writes an error object as a nicely-formatted, user-readable error message, including source file names and locations.",4,null],[11,"description","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",4,{"inputs":[{"name":"borrowerror"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"borrowmuterror"}],"output":{"name":"self"}}],[0,"lexer","phile","This module contains type definitions and functions for breaking up unstructured source text into lexemes and tokens. It also provides types for mapping tokens to their original location within the source code in a human-readable manner.",null,null],[3,"Location","phile::lexer","Represents the location of a single extended grapheme cluster in the sources fed to the lexer.",null,null],[12,"src_idx","","0-based index of the source that this location points into.",5,null],[12,"line","","1-based line index within the aforementioned source.",5,null],[12,"column","","1-based character index within the line.",5,null],[3,"Range","","A half-open range representing a source span.",null,null],[12,"begin","","Location at the beginning of the source range.",6,null],[12,"end","","Location one past the end of the source range.",6,null],[3,"Token","","Represents a lexeme and its associated type and location information as an abstract token.",null,null],[12,"kind","","The kind associated with the recognized lexeme.",7,null],[12,"value","","A pointer into the source where the underlying lexeme was found.",7,null],[12,"range","","Human-readable range information for the underlying lexeme.",7,null],[4,"TokenKind","","Describes the type of a single token or lexeme.",null,null],[13,"Whitespace","","Horizontal and vertical (e.g. newline) whitespace. Unicode-aware.",8,null],[13,"Comment","","Currently, a line comment, beginning with '#' and ending with vertical whitespace or end-of-source.",8,null],[13,"Word","","An identifier or a keyword.",8,null],[13,"Punctuation","","Operators and other punctuation characters, e.g. semicolons.",8,null],[13,"StringLiteral","","String literal.",8,null],[13,"NumericLiteral","","Integer or floating-point literal.",8,null],[5,"lex","","Given an array of source strings, returns an array of tokens extracted from those strings, or an error if there is a syntactic (more precisely, lexical) error in any of the source strings.",null,null],[8,"Ranged","","This trait is to be implemented by entities that correspond to some range in the source. This is used for generating location information in user-visible error messages.",null,null],[10,"range","","Returns the range `self` was generated from.",9,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"location"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"location"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"option"}}],[11,"lt","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"le","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"gt","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"ge","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"self"},{"name":"location"}],"output":{"name":"ordering"}}],[11,"hash","","",5,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"range"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"ordering"}}],[11,"hash","","",6,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"tokenkind"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",8,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"option"}}],[11,"cmp","","",8,{"inputs":[{"name":"self"},{"name":"tokenkind"}],"output":{"name":"ordering"}}],[11,"hash","","",8,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"hash","","",7,null],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"range","","",6,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",7,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[0,"ast","phile","This module contains types for building Abstract Syntax Trees (ASTs). ASTs describe the syntactic structure of PHiLe programs. Defined here are various kinds of AST nodes that the `parser` module emits from a sequence of tokens produced by the `lexer` module. AST nodes, like tokens, contain source location data in order to easily map them to the original source code.",null,null],[3,"Prog","phile::ast","Root of the AST.",null,null],[12,"items","","The list of top-level items: type and function definitions or `impl`s.",10,null],[3,"Node","","Generic AST node (helper for Exp, Ty, etc.)",null,null],[12,"kind","","Discriminant describing the type and value of the node.",11,null],[12,"range","","Source range that this node was generated from.",11,null],[3,"StructDecl","","Definition of a `struct` type.",null,null],[12,"range","","The source range of the type definition.",12,null],[12,"name","","The name of the struct type.",12,null],[12,"fields","","The fields of the struct type.",12,null],[3,"ClassDecl","","Definition of a `class` type.",null,null],[12,"range","","The source range of the type definition.",13,null],[12,"name","","The name of the class type.",13,null],[12,"fields","","The fields of the class type.",13,null],[3,"RelDecl","","Declaration of an explicit relation between two class types. A `RelDecl` node semantically means that the LHS of the relation is the class in which the `RelDecl` is contained, while the RHS is the type of the corresponding field.",null,null],[12,"cardinality","","The cardinality operator.",14,null],[12,"field","","The name of the field in the RHS that points back to the LHS class, forming the inverse relation. If the relation has no explicit inverse, this is `None`.",14,null],[3,"Field","","A field specification within a struct or class type definition.",null,null],[12,"range","","The source range of the field definition.",15,null],[12,"name","","The name of the field.",15,null],[12,"ty","","The declared type of the field.",15,null],[12,"relation","","Optional explicit relation specification for the field.",15,null],[3,"EnumDecl","","Definition of an `enum` type.",null,null],[12,"range","","The source range of the type definition.",16,null],[12,"name","","The name of the `enum` type.",16,null],[12,"variants","","The list of variants in the enum type.",16,null],[3,"Variant","","Definition of one enum variant.",null,null],[12,"range","","Source range of the definition.",17,null],[12,"name","","The name of the variant.",17,null],[12,"ty","","Type of the contained value of the variant, if any.",17,null],[3,"Function","","A function definition.",null,null],[12,"range","","Source range of the function.",18,null],[12,"name","","Name of the function if it is a named global, `None` for closures.",18,null],[12,"arguments","","The list of arguments to the function.",18,null],[12,"ret_type","","The return type specification, if present.",18,null],[12,"body","","The function body expression.",18,null],[3,"FuncArg","","Declaration of a single function argument.",null,null],[12,"range","","Source range of the declaration.",19,null],[12,"name","","Name of the argument.",19,null],[12,"ty","","Type specification of the argument, if present.",19,null],[3,"Impl","","Implementation of the methods of a user-defined type.",null,null],[12,"range","","Source range if the `impl`.",20,null],[12,"name","","Name of the type for which methods are implemented.",20,null],[12,"functions","","The list of methods in the implementation.",20,null],[3,"CondExp","","A conditional expression or 'Elvis operator', `?:`.",null,null],[12,"condition","","The LHS is the condition.",21,null],[12,"true_val","","The value when the condition is true. `None` when `?:` is used as the nil coalescing operator, e.g. `foo ?: default`.",21,null],[12,"false_val","","The value when the condition is false or `nil`.",21,null],[3,"BinaryOp","","Any binary operator.",null,null],[12,"op","","Textual representation of the operator itself.",22,null],[12,"lhs","","The left-hand side operand.",22,null],[12,"rhs","","The right-hand side operand.",22,null],[3,"Subscript","","An indexing or subscripting operator.",null,null],[12,"base","","The expression being indexed into.",23,null],[12,"index","","The expression being used as the subscript in brackets.",23,null],[3,"MemberAccess","","Dot syntax for accessing fields and methods.",null,null],[12,"base","","The expression of which a field or method is requested.",24,null],[12,"member","","The name of the field or method being accessed.",24,null],[3,"QualAccess","","Namespace-style member access, for e.g. enums.",null,null],[12,"base","","The expression of which a member is requested.",25,null],[12,"member","","The name of the member.",25,null],[3,"FuncCall","","A function call operation.",null,null],[12,"function","","The LHS, that is, the function being called.",26,null],[12,"arguments","","The RHS, that is, the list of actual arguments.",26,null],[3,"StructLiteral","","A struct literal.",null,null],[12,"name","","Name of the struct type being instantiated.",27,null],[12,"fields","","The list of fields: `(name, value)`.",27,null],[3,"If","","An if statement or expression.",null,null],[12,"condition","","The Boolean condition of the `if`.",28,null],[12,"then_arm","","The expression evaulated when the condition is true.",28,null],[12,"else_arm","","The expression evaluated when the condition is false.",28,null],[3,"Match","","A match statement or expression.",null,null],[12,"discriminant","","The value to match.",29,null],[12,"arms","","The list of patterns and the expressions that are evaluated when one of them matches: `(pattern, expression)`.",29,null],[3,"VarDecl","","A variable declaration statement for locals.",null,null],[12,"name","","The name of the local variable.",30,null],[12,"ty","","The type specification of the variable, if present.",30,null],[12,"expr","","The initializer expression of the variable.",30,null],[3,"FunctionTy","","A function type.",null,null],[12,"arg_types","","The list of argument types the function takes, in order.",31,null],[12,"ret_type","","The return type of the function.",31,null],[4,"Item","","A top-level source item.",null,null],[13,"StructDecl","","Definition of a `struct` type.",32,null],[13,"ClassDecl","","Definition of a `class` type.",32,null],[13,"EnumDecl","","Definition of an `enum` type.",32,null],[13,"FuncDef","","A global, free function.",32,null],[13,"Impl","","`impl`, implementation of the methods of a type.",32,null],[4,"ExpKind","","Type and value of an `Exp` expression node.",null,null],[13,"CondExp","","`?:`, the Elvis operator.",33,null],[13,"BinaryOp","","Any binary infix operator.",33,null],[13,"Cast","","A cast expression: `lhs as Rhs`",33,null],[13,"UnaryPlus","","Unary prefix plus operator.",33,null],[13,"UnaryMinus","","Unary prefix negation operator.",33,null],[13,"LogicNot","","Logical `not` operator.",33,null],[13,"Subscript","","Indexing/subscripting postfix operator.",33,null],[13,"MemberAccess","","Dot syntax: struct/class field or method access.",33,null],[13,"QualAccess","","Namespace access, `foo::bar`",33,null],[13,"FuncCall","","Function call",33,null],[13,"NilLiteral","","Literal `nil`",33,null],[13,"BoolLiteral","","Literal `true` or `false`.",33,null],[13,"IntLiteral","","An unparsed integer literal, without a sign.",33,null],[13,"FloatLiteral","","An unparsed floating-point literal.",33,null],[13,"StringLiteral","","A still potentially escaped string literal.",33,null],[13,"Identifier","","The name of an entity, e.g. function, variable, or type.",33,null],[13,"TupleLiteral","","A tuple literal.",33,null],[13,"ArrayLiteral","","An array literal.",33,null],[13,"StructLiteral","","A struct literal.",33,null],[13,"If","","An if expression or statement.",33,null],[13,"Match","","A match expression or statement.",33,null],[13,"Block","","A block expression or statement.",33,null],[13,"FuncExp","","A function literal, \"lambda\".",33,null],[13,"VarDecl","","A local variable declaration.",33,null],[13,"Semi","","An expression turned into a statement by a trailing semicolon.",33,null],[13,"Empty","","An empty statement, just a semicolon.",33,null],[4,"TyKind","","Type and value of a `Ty` type node.",null,null],[13,"Pointer","","A pointer to the inner type.",34,null],[13,"Optional","","An optional wrapping the inner type.",34,null],[13,"Tuple","","A tuple of the inner types.",34,null],[13,"Array","","An array of the inner type.",34,null],[13,"Function","","A function type.",34,null],[13,"Named","","Named types: builtins and user-defined structs/classes/enums",34,null],[6,"Exp","","AST node representing an expression.",null,null],[6,"Ty","","AST node representing a type annotation.",null,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"prog"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"prog"}],"output":{"name":"bool"}}],[11,"hash","","",10,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"hash","","",11,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"item"}],"output":{"name":"bool"}}],[11,"ne","","",32,{"inputs":[{"name":"self"},{"name":"item"}],"output":{"name":"bool"}}],[11,"hash","","",32,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",33,{"inputs":[{"name":"self"},{"name":"expkind"}],"output":{"name":"bool"}}],[11,"ne","","",33,{"inputs":[{"name":"self"},{"name":"expkind"}],"output":{"name":"bool"}}],[11,"hash","","",33,null],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"tykind"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"self"},{"name":"tykind"}],"output":{"name":"bool"}}],[11,"hash","","",34,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"structdecl"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"structdecl"}],"output":{"name":"bool"}}],[11,"hash","","",12,null],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"classdecl"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"classdecl"}],"output":{"name":"bool"}}],[11,"hash","","",13,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"reldecl"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"reldecl"}],"output":{"name":"bool"}}],[11,"hash","","",14,null],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"field"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"field"}],"output":{"name":"bool"}}],[11,"hash","","",15,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"enumdecl"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"enumdecl"}],"output":{"name":"bool"}}],[11,"hash","","",16,null],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"variant"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"variant"}],"output":{"name":"bool"}}],[11,"hash","","",17,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"bool"}}],[11,"ne","","",18,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"bool"}}],[11,"hash","","",18,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"funcarg"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"funcarg"}],"output":{"name":"bool"}}],[11,"hash","","",19,null],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"impl"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"impl"}],"output":{"name":"bool"}}],[11,"hash","","",20,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"condexp"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"condexp"}],"output":{"name":"bool"}}],[11,"hash","","",21,null],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"binaryop"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"binaryop"}],"output":{"name":"bool"}}],[11,"hash","","",22,null],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"subscript"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"self"},{"name":"subscript"}],"output":{"name":"bool"}}],[11,"hash","","",23,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"memberaccess"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"memberaccess"}],"output":{"name":"bool"}}],[11,"hash","","",24,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"qualaccess"}],"output":{"name":"bool"}}],[11,"ne","","",25,{"inputs":[{"name":"self"},{"name":"qualaccess"}],"output":{"name":"bool"}}],[11,"hash","","",25,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"funccall"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"self"},{"name":"funccall"}],"output":{"name":"bool"}}],[11,"hash","","",26,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"structliteral"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"structliteral"}],"output":{"name":"bool"}}],[11,"hash","","",27,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"if"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"if"}],"output":{"name":"bool"}}],[11,"hash","","",28,null],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"match"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"self"},{"name":"match"}],"output":{"name":"bool"}}],[11,"hash","","",29,null],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"vardecl"}],"output":{"name":"bool"}}],[11,"ne","","",30,{"inputs":[{"name":"self"},{"name":"vardecl"}],"output":{"name":"bool"}}],[11,"hash","","",30,null],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"functionty"}],"output":{"name":"bool"}}],[11,"ne","","",31,{"inputs":[{"name":"self"},{"name":"functionty"}],"output":{"name":"bool"}}],[11,"hash","","",31,null],[11,"range","","",12,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",13,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",15,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",16,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",17,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",18,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",19,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",20,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",11,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"range","","",32,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[0,"parser","phile","This module provides a function, `parse()`, for building an Abstract Syntax Tree out of a flat sequence of `Token`s, itself generated by the `lexer` module. The module depends on the `ast` module for providing the emitted node types.",null,null],[5,"parse","phile::parser","Given an array of tokens, parses the token sequence, and returns the corresponding AST.",null,null],[0,"sqir","phile","Defines SQIR, the Schema and Query Intermediate Representation. SQIR is the intermediate language of PHiLe, on which optimizations are performed. SQIR is also the starting point of code generation for database abstraction layers.",null,null],[3,"BuiltinName","phile::sqir","Centralized container for the name of each builtin type.",null,null],[12,"bool_name","","",35,null],[12,"int_name","","",35,null],[12,"float_name","","",35,null],[12,"decimal_name","","",35,null],[12,"string_name","","",35,null],[12,"blob_name","","",35,null],[12,"date_name","","",35,null],[3,"EnumType","","Describes an enumerated type.",null,null],[12,"name","","The name of the enum type.",36,null],[12,"variants","","The list of variants: keys are variant names, each value is the type of the associated value of the variant.",36,null],[3,"StructType","","Describes a structure type.",null,null],[12,"name","","The name of the struct type.",37,null],[12,"fields","","The list of fields: keys are the field names; each value is the type of the referred field.",37,null],[3,"ClassType","","Describes a class type.",null,null],[12,"name","","The name of the class type.",38,null],[12,"fields","","The list of fields: keys are the field names; each value is the type of the referred field.",38,null],[3,"FunctionType","","Describes a function type.",null,null],[12,"arg_types","","The list of types of each argument in order.",39,null],[12,"ret_type","","The return type of the function.",39,null],[3,"RelationSide","","Represents one side of a relationship between two entities. A particular `RelationSide` always describes the relation from the point of view of one particular entity type.",null,null],[12,"entity","","Pointer to the type which forms this side of the relationship.",40,null],[12,"field","","Name of the field this side uses to refer to the other side.",40,null],[12,"cardinality","","Number of instances of this entity that may correspond to an instance in the other entity.",40,null],[3,"Relation","","An entity relationship is an unordered pair of relation sides.",null,null],[12,"lhs","","One side of the relationship.",41,null],[12,"rhs","","The other side of the relationship.",41,null],[3,"Expr","","Expression: the core data structure. This type is more or less a lambda calculus node on steroids.",null,null],[12,"ty","","The type of the expression.",42,null],[12,"value","","The value of the expression.",42,null],[12,"id","","The identifier of the expression, unique within a top-level function.",42,null],[3,"AttrRef","","A reference to 0 or more attributes of a certain entity. Used for simple, optimized operations (e.g. projections).",null,null],[12,"entity","","The entity of which some fields should be examined.",43,null],[12,"fields","","The names of some fields of the entity.",43,null],[3,"Function","","A function. This is the value of global functions and closures.",null,null],[12,"args","","Each function argument in order; `FuncArg` expressions.",44,null],[12,"body","","The expression that is evaluated when the function is called.",44,null],[3,"Call","","A function call expression.",null,null],[12,"callee","","The function being called.",45,null],[12,"args","","The list of actual arguments, in order.",45,null],[3,"Branch","","A multi-way branch expression. The way to do control flow.",null,null],[12,"discriminant","","The expression that control flow will depend on.",46,null],[12,"arms","","The patterns that match the discriminant, along with their associated expression that will be evaluated upon match.",46,null],[3,"BranchArm","","A match-value pair, representing one possible direction of control flow.",null,null],[12,"pattern","","The pattern that may match the discriminant.",47,null],[12,"value","","The expression to evaluated when `pattern` matches.",47,null],[3,"Map","","A general `map` or projection operation.",null,null],[12,"domain","","The sequence/collection which is the domain of the projection.",48,null],[12,"op","","A unary function applied to every element of `domain`.",48,null],[3,"Reduce","","A general `reduce` or aggregation operation.",null,null],[12,"domain","","The domain of the aggregation (see `Map` too).",49,null],[12,"zero","","The identity element of the operation.",49,null],[12,"op","","A binary operation on the next element and the previous partial result.",49,null],[3,"Filter","","A general `filter` or selection operation.",null,null],[12,"domain","","The domain of the selection (see `Map` too).",50,null],[12,"pred","","The unary, boolean-valued predicate applied to each element of the domain.",50,null],[3,"Sort","","A general sorting operation.",null,null],[12,"domain","","The domain of the sorting operation.",51,null],[12,"cmp","","Binary, boolean-valued comparison function for `LHS < RHS`.",51,null],[3,"Group","","A general grouping operation.",null,null],[12,"domain","","Elements to be grouped.",52,null],[12,"key","","A function that returns a key that grouping will be based on.",52,null],[3,"Sqir","","Top-level type for wrapping SQIR for a complete program. Field names are (hopefully) self-explanatory.",null,null],[12,"named_types","","Stores named builtins and user-defined types.",53,null],[12,"decimal_types","","Stores decimal types, parametrized by `(integral_digits, fractional_digits)`.",53,null],[12,"optional_types","","Stores cached optional types. Keys are the inner, wrapped types.",53,null],[12,"pointer_types","","Stores cached pointer types. Keys are pointed types.",53,null],[12,"array_types","","Stores cached array types. Keys are element types.",53,null],[12,"tuple_types","","Stores cached tuple types. Keys are the product of contained types.",53,null],[12,"function_types","","Stores cached function types. Keys are `([argument_types], return_type)`.",53,null],[12,"relations","","Stores relations between entities. Keys are `(referring_entity, referring_field)`.",53,null],[12,"globals","","Stores global values (currently, functions only). Keys are namespace (`impl`) names; `None` means top-level/free function, not in an `impl`.",53,null],[4,"Type","","`Type` is deliberately not `Clone`, `PartialEq` and `Eq`: it is meant to be used only with `RcCell`/`WkCell`, and its instances should be compared by address.",null,null],[13,"Bool","","Boolean type.",54,null],[13,"Int","","Signed integer type.",54,null],[13,"Float","","Floating-point type.",54,null],[13,"Decimal","","Decimal number type.",54,null],[12,"integral","phile::sqir::Type","The number of digits in the integral part of the number.",54,null],[12,"fractional","","The number of digits in the fractional part of the number.",54,null],[13,"String","phile::sqir","String type.",54,null],[13,"Blob","","Binary Large Object type.",54,null],[13,"Date","","Date type; a single point in time.",54,null],[13,"Optional","","Optional type: either a wrapped value or `nil`.",54,null],[13,"Pointer","","Pointer type. An external reference to an entity.",54,null],[13,"Array","","Array type. An ordered list of values.",54,null],[13,"Tuple","","Tuple type. An ad-hoc product type.",54,null],[13,"Enum","","An enumerated (sum) type.",54,null],[13,"Struct","","A structure type: a product type with named fields.",54,null],[13,"Class","","A class type: a product and entity type with named fields.",54,null],[13,"Function","","A Function type.",54,null],[13,"Placeholder","","A placeholder type. Only exists during typechecking.",54,null],[12,"name","phile::sqir::Type","The name of the type this placeholder temporarily stands for.",54,null],[12,"kind","","The kind of the type this placeholder stands for.",54,null],[4,"PlaceholderKind","phile::sqir","The kind of the type a placeholder type stands for.",null,null],[13,"Struct","","Indicates that the placeholder stands for a `struct` type.",55,null],[13,"Class","","Indicates that the placeholder stands for a `class` type.",55,null],[13,"Enum","","Indicates that the placeholder stands for an `enum` type.",55,null],[4,"ComplexTypeKind","","A bit of terminology:",null,null],[13,"Value","","A complex type that is a value type: `struct`, `enum`, tuple",56,null],[13,"Entity","","A complex type that is an entity type: currently, only `class`.",56,null],[13,"Function","","A complex type that is a function type.",56,null],[4,"Cardinality","","The cardinality or multiplicity shows how many entities in the referred side may be related to each entity in the referring side.",null,null],[13,"ZeroOrOne","","Optional relationship: an instance on this side may or may not correspond to an instance on the other side.",57,null],[13,"One","","Required, unique relationship: exactly one instance on this side must correspond to an instance at the other side.",57,null],[13,"ZeroOrMore","","Optional, multiple-valued relationship: any or no instances on this side may correspond to an instance on the other side.",57,null],[13,"OneOrMore","","Required, multiple-valued relationship: at least one instance on this side must correspond to an instance on the other side.",57,null],[4,"Value","","Represents the value of an expression node.",null,null],[13,"Placeholder","","Value of a forward-declared function",58,null],[13,"Nil","","A nil constant.",58,null],[13,"BoolConst","","A Boolean constant.",58,null],[13,"IntConst","","An integral constant.",58,null],[13,"FloatConst","","A floating-point constant.",58,null],[13,"StringConst","","A string constant.",58,null],[13,"Function","","A function definition (~lambda expression).",58,null],[13,"Call","","A function call (~application).",58,null],[13,"FuncArg","","A function argument. This has its own variant because it makes optimizations significantly easier.",58,null],[12,"func","phile::sqir::Value","A back-pointer to the containing function.",58,null],[12,"index","","0-based index of the argument within its containing function.",58,null],[13,"Load","phile::sqir","A name reference (~substitution). The wrapped expression is the underlying expression referred to by the \"variable\". Variable declarations are implicit using named expressions. It must be weak, because the body of a named (eg. global) recursive function can refer to itself.",58,null],[13,"OptionalWrap","","T -> T? conversion. Usually emitted from an implicit promotion. Each conversion generates a new temporary, therefore these conversions cannot form a reference cycle, so it's OK to make their associated value a strong pointer.",58,null],[13,"Ignore","","Explicit T -> () conversion. Usually emitted by an expression statement.",58,null],[13,"Neg","","Numeric unary negation operation.",58,null],[13,"Add","","Addition operation.",58,null],[13,"Sub","","Subtraction operation.",58,null],[13,"Mul","","Multiplication operation.",58,null],[13,"Div","","Division operation.",58,null],[13,"Mod","","Modulus (or remainder?) operation.",58,null],[13,"Eq","","Equality comparison.",58,null],[13,"Neq","","Inequality comparison.",58,null],[13,"Lt","","\"Less than\" comparison.",58,null],[13,"LtEq","","\"Less than or equal to\" comparison.",58,null],[13,"Gt","","\"Greater than\" comparison.",58,null],[13,"GtEq","","\"Greater than or equal to\" comparison.",58,null],[13,"And","","Logical conjunction.",58,null],[13,"Or","","Logical disjunction.",58,null],[13,"Not","","Logical negation.",58,null],[13,"Intersect","","Set intersection.",58,null],[13,"Union","","Set union.",58,null],[13,"SetDiff","","Set difference.",58,null],[13,"Branch","","Multi-way branch.",58,null],[13,"Seq","","An ordered sequence of expressions; a block. Evaluates each expression and yields the last one.",58,null],[13,"Array","","An array literal.",58,null],[13,"Tuple","","A tuple literal.",58,null],[13,"StructLiteral","","A struct literal. Keys are field names, values are the corresponding expressions.",58,null],[13,"Map","","Generalized projection.",58,null],[13,"Reduce","","Generalized aggregation.",58,null],[13,"Filter","","Generalized selection.",58,null],[13,"Sort","","Generalized sorting.",58,null],[13,"Group","","Generalized grouping.",58,null],[13,"Join","","A join operation between entities. TODO(H2CO3): design + implement this.",58,null],[13,"Insert","","An insertion into some entities in the database. TODO(H2CO3): design + implement this.",58,null],[13,"Update","","An update affecting some entities in the database. TODO(H2CO3): design + implement this.",58,null],[13,"Project","","Simple projection of one or more named columns of the given type. Only emitted by SQIROpt.",58,null],[13,"GroupBy","","Simple grouping based on one or more named columns of the given type. Column names are in decreasing order of significance (\"outer first\"). Only emitted by SQIROpt.",58,null],[13,"SortBy","","Simple sorting based on one or more named columns of the given type. Column names are in decreasing order of (lexicographical) significance. Only emitted by SQIROpt.",58,null],[12,"entity","phile::sqir::Value","The entity to sort.",58,null],[12,"fields","","Names of fields used as sort keys, in lexicographical order of importance.",58,null],[13,"Sum","phile::sqir","Project the sum of some attributes of a given type. Only emitted by SQIROpt.",58,null],[13,"Avg","","Project the average of some attributes of a given type. Only emitted by SQIROpt.",58,null],[13,"Min","","Project the minimum of some attributes of a given type. Only emitted by SQIROpt.",58,null],[13,"Max","","Project the maximum of some attributes of a given type. Only emitted by SQIROpt.",58,null],[4,"SortDirection","","A flag for indicating the direction of sorting. The default is `Ascending`.",null,null],[13,"Ascending","","Order smaller values before greater ones.",59,null],[13,"Descending","","Order greater values before smaller ones.",59,null],[4,"ExprId","","`ExprId` is deliberately not `Clone`: it should not be copied.",null,null],[13,"Temp","","A temporary. The integer is its ID, unique within a global `fn`.",60,null],[13,"Local","","A local \"variable\" declaration, more precisely a name binding.",60,null],[13,"Global","","A global. (For now, a function.) Contained `String` is its name.",60,null],[6,"RcType","","Convenience type alias for a reference-counted type descriptor.",null,null],[6,"WkType","","Weak counterpart of `RcType`.",null,null],[6,"RcExpr","","Convenience type alias for a reference-counted expression node.",null,null],[6,"WkExpr","","Weak counterpart of `RcExpr`.",null,null],[7,"BUILTIN_NAME","","The \"singleton\" `BuiltinName` instance.",null,null],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"builtinname"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",55,{"inputs":[{"name":"self"}],"output":{"name":"placeholderkind"}}],[11,"eq","","",55,{"inputs":[{"name":"self"},{"name":"placeholderkind"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",55,{"inputs":[{"name":"self"},{"name":"placeholderkind"}],"output":{"name":"option"}}],[11,"cmp","","",55,{"inputs":[{"name":"self"},{"name":"placeholderkind"}],"output":{"name":"ordering"}}],[11,"hash","","",55,null],[11,"fmt","","",56,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",56,{"inputs":[{"name":"self"}],"output":{"name":"complextypekind"}}],[11,"eq","","",56,{"inputs":[{"name":"self"},{"name":"complextypekind"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",56,{"inputs":[{"name":"self"},{"name":"complextypekind"}],"output":{"name":"option"}}],[11,"cmp","","",56,{"inputs":[{"name":"self"},{"name":"complextypekind"}],"output":{"name":"ordering"}}],[11,"hash","","",56,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"functiontype"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"relationside"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"relationside"}],"output":{"name":"bool"}}],[11,"ne","","",40,{"inputs":[{"name":"self"},{"name":"relationside"}],"output":{"name":"bool"}}],[11,"fmt","","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",57,{"inputs":[{"name":"self"}],"output":{"name":"cardinality"}}],[11,"eq","","",57,{"inputs":[{"name":"self"},{"name":"cardinality"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",57,{"inputs":[{"name":"self"},{"name":"cardinality"}],"output":{"name":"option"}}],[11,"cmp","","",57,{"inputs":[{"name":"self"},{"name":"cardinality"}],"output":{"name":"ordering"}}],[11,"hash","","",57,null],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",59,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",59,{"inputs":[{"name":"self"}],"output":{"name":"sortdirection"}}],[11,"eq","","",59,{"inputs":[{"name":"self"},{"name":"sortdirection"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",59,{"inputs":[{"name":"self"},{"name":"sortdirection"}],"output":{"name":"option"}}],[11,"cmp","","",59,{"inputs":[{"name":"self"},{"name":"sortdirection"}],"output":{"name":"ordering"}}],[11,"hash","","",59,null],[11,"default","","",59,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"ne","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"option"}}],[11,"lt","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"le","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"gt","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"ge","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"bool"}}],[11,"cmp","","",60,{"inputs":[{"name":"self"},{"name":"exprid"}],"output":{"name":"ordering"}}],[11,"hash","","",60,null],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"function"}}],[11,"fmt","","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",46,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",40,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"cmp","","",40,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"eq","","",41,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",41,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"option"}}],[11,"cmp","","",41,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"new","","Creates an \"empty\" SQIR value, populated with builtins only.",53,{"inputs":[],"output":{"name":"sqir"}}],[11,"unique_relations","","Relations can be stored either once or twice in the `relations` field (because they need to be associated with named sides for easy querygen), but schemagen still requires a non-redundant set of relations. By convention, `relations` contains relations in a way that the RelationSide corresponding to the key appears on the LHS, whereas the referred RelationSide is the RHS.",53,{"inputs":[{"name":"self"}],"output":{"name":"btreeset"}}],[11,"default","","",53,{"inputs":[],"output":{"name":"sqir"}}],[0,"sqirgen","phile","This module provides functionality to convert an Abstract Syntax Tree into PHiLe's intermediate language, SQIR (short for Schema and Query Intermediate Representation).",null,null],[5,"generate_sqir","phile::sqirgen","Takes a borrowed AST, performs various kinds of semantic analysis on it, and if it represents a correct program, then outputs the corresponding SQIR code.",null,{"inputs":[{"name":"prog"}],"output":{"name":"result"}}],[0,"sqiropt","phile","This module provides facilities for optimizing PHiLe programs in SQIR format.",null,null],[5,"optimize_sqir","phile::sqiropt","Performs optimizations on naively-generated SQIR (as emitted by SQIRGen).",null,{"inputs":[{"name":"sqir"}],"output":{"name":"sqir"}}],[0,"dalgen","phile","DALGen, the backend of the PHiLe compiler. This is the part that generates actual code in your programming language of choice for a Database Abstraction Layer from optimized SQIR.",null,null],[3,"CodegenParams","phile::dalgen","A bunch of centralized settings governing the behavior of DALGen.",null,null],[12,"database","","The database flavor to be targeted. See the docs of `DatabaseEngine`.",61,null],[12,"language","","The programming language to be targeted. See the docs of `Language`.",61,null],[12,"database_access_mode","","Database access strategy. See the docs for `DatabaseAccessMode`.",61,null],[12,"namespace","","Namespace name. This will be used in different ways for different programming languages. For example, in Go, it will be the package name, and is thus mandatory.",61,null],[12,"type_name_transform","","The transform to be applied to names of user-defined types.",61,null],[12,"field_name_transform","","The transform to be applied to fields of `struct`s and `class`es.",61,null],[12,"variant_name_transform","","The transform to be applied to variants of `enum`s.",61,null],[12,"func_name_transform","","The transform to be applied to names of user-defined functions.",61,null],[12,"namespace_transform","","The transform to be applied to the name of the namespace.",61,null],[4,"DatabaseEngine","","The database engine flavor for which a Database Abstraction Layer will be generated.",null,null],[13,"SQLite3","","SQLite, a very lightweight, embeddable, relational database.",62,null],[13,"MongoDB","","MongoDB, a JSON document store.",62,null],[13,"MariaDB","","MariaDB, a GPL fork of the MySQL RMDBS.",62,null],[4,"Language","","The programming language in which the DAL will be implemented.",null,null],[13,"Rust","","Rust 1.x.",63,null],[13,"C","","C. 89/90? 99? 11? I don't know yet.",63,null],[13,"CXX","","Modern C++ (11, 14, 17).",63,null],[13,"ObjectiveC","","Modern Objective-C (2.0).",63,null],[13,"Swift","","Swift. I don't write a version number because it will change anyway.",63,null],[13,"Go","","Go 1.x.",63,null],[13,"JavaScript","","ECMAScript, if we are being technical.",63,null],[13,"Python","","Python. 2 or 3? I don't know yet.",63,null],[13,"Java","","Java. Yeah, seriously.",63,null],[4,"DatabaseAccessMode","","The strategy with which the generated DAL will query the DB.",null,null],[13,"Pod","","POD, or Plain Old Object: objects returned from the DAL are immutable and do not automatically synchronize their state with the DB. This may be better for performance.",64,null],[13,"ActiveRecord","","Active Records: objects returned by the DAL are mutable and they automatically synchronize their state with the DB. May be better for application-level consistency.",64,null],[4,"NameTransform","","The rewriting strategy applied to various kinds of named program elements, such as function, variable, and type names. In the `CodegenParams` struct, optional instances of this transform are specified, where `None` means \"default for the programming language\".",null,null],[13,"Identity","","Don't touch it!",65,null],[13,"LowerSnakeCase","","`lower_snake_case`. Isn't SnakeCase spelled with camel case ironic, by the way?",65,null],[13,"UpperSnakeCase","","`UPPER_SNAKE_CASE`. Use this only when you are frustrated and want to yell.",65,null],[13,"LowerCamelCase","","`lowerCamelCase`.",65,null],[13,"UpperCamelCase","","`UpperCamelCase`, also known as `PascalCase`.",65,null],[5,"generate_dal","","Given the SQIR representation of a program, and some configuration parameters, generates a Database Abstraction Layer and writes the code into `io::Write`s.",null,{"inputs":[{"name":"sqir"},{"name":"codegenparams"},{"name":"writerprovider"}],"output":{"name":"result"}}],[6,"WriterProvider","","Functions of this type are expected to yield a (possibly cached) `io::Write` object that DALGen can write to. The cache key, specified as the string parameter of the function, is sometimes a file name derived from the `impl` of a user-defined type.",null,null],[11,"fmt","","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"databaseengine"}}],[11,"eq","","",62,{"inputs":[{"name":"self"},{"name":"databaseengine"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",62,{"inputs":[{"name":"self"},{"name":"databaseengine"}],"output":{"name":"option"}}],[11,"cmp","","",62,{"inputs":[{"name":"self"},{"name":"databaseengine"}],"output":{"name":"ordering"}}],[11,"hash","","",62,null],[11,"fmt","","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"language"}}],[11,"eq","","",63,{"inputs":[{"name":"self"},{"name":"language"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",63,{"inputs":[{"name":"self"},{"name":"language"}],"output":{"name":"option"}}],[11,"cmp","","",63,{"inputs":[{"name":"self"},{"name":"language"}],"output":{"name":"ordering"}}],[11,"hash","","",63,null],[11,"fmt","","",64,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"databaseaccessmode"}}],[11,"eq","","",64,{"inputs":[{"name":"self"},{"name":"databaseaccessmode"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",64,{"inputs":[{"name":"self"},{"name":"databaseaccessmode"}],"output":{"name":"option"}}],[11,"cmp","","",64,{"inputs":[{"name":"self"},{"name":"databaseaccessmode"}],"output":{"name":"ordering"}}],[11,"hash","","",64,null],[11,"fmt","","",65,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",65,{"inputs":[{"name":"self"}],"output":{"name":"nametransform"}}],[11,"eq","","",65,{"inputs":[{"name":"self"},{"name":"nametransform"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",65,{"inputs":[{"name":"self"},{"name":"nametransform"}],"output":{"name":"option"}}],[11,"cmp","","",65,{"inputs":[{"name":"self"},{"name":"nametransform"}],"output":{"name":"ordering"}}],[11,"hash","","",65,null],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",61,{"inputs":[{"name":"self"}],"output":{"name":"codegenparams"}}],[11,"eq","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"ne","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"option"}}],[11,"lt","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"le","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"gt","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"ge","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"bool"}}],[11,"cmp","","",61,{"inputs":[{"name":"self"},{"name":"codegenparams"}],"output":{"name":"ordering"}}],[11,"hash","","",61,null]],"paths":[[3,"PackageInfo"],[3,"Color"],[3,"RcCell"],[3,"WkCell"],[4,"Error"],[3,"Location"],[3,"Range"],[3,"Token"],[4,"TokenKind"],[8,"Ranged"],[3,"Prog"],[3,"Node"],[3,"StructDecl"],[3,"ClassDecl"],[3,"RelDecl"],[3,"Field"],[3,"EnumDecl"],[3,"Variant"],[3,"Function"],[3,"FuncArg"],[3,"Impl"],[3,"CondExp"],[3,"BinaryOp"],[3,"Subscript"],[3,"MemberAccess"],[3,"QualAccess"],[3,"FuncCall"],[3,"StructLiteral"],[3,"If"],[3,"Match"],[3,"VarDecl"],[3,"FunctionTy"],[4,"Item"],[4,"ExpKind"],[4,"TyKind"],[3,"BuiltinName"],[3,"EnumType"],[3,"StructType"],[3,"ClassType"],[3,"FunctionType"],[3,"RelationSide"],[3,"Relation"],[3,"Expr"],[3,"AttrRef"],[3,"Function"],[3,"Call"],[3,"Branch"],[3,"BranchArm"],[3,"Map"],[3,"Reduce"],[3,"Filter"],[3,"Sort"],[3,"Group"],[3,"Sqir"],[4,"Type"],[4,"PlaceholderKind"],[4,"ComplexTypeKind"],[4,"Cardinality"],[4,"Value"],[4,"SortDirection"],[4,"ExprId"],[3,"CodegenParams"],[4,"DatabaseEngine"],[4,"Language"],[4,"DatabaseAccessMode"],[4,"NameTransform"]]};
searchIndex["philec"] = {"doc":"`philec` is the command-line driver for the PHiLe Compiler.","items":[],"paths":[]};
initSearch(searchIndex);
