<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" href="index.css" />
    <title>H2CO3's Projects</title>
  </head>
  <body>
    <h2 style="text-align: center"><a href="Arpad_Goretity_CV.pdf">H2CO3's Curriculum Vit&aelig;</a></h2>
    <br style='width: 1px; line: dotted' />
    <hr style="border: 1px dotted #3f3f3f;" />
    <h2 class="pagetitle">H2CO3's Blog</h2>
    <h3><a href="rust2019">The Last Thing Rust Needs</a></h3>
    <p>On the future of Rust, based on musings about programming language design by world-famous C++ expert Scott Meyers.</p>
    <h3><a href="pattern">Patterns Are Not Expressions</a></h3>
    <p>In which I explain the One True Way&trade; you should think about patterns and pattern matching in Rust, because seemingly nobody gets it.</p>
    <h2 class="pagetitle">H2CO3's Projects</h2>
    <p class="subtitle" style="font-style: italic; font-size: 13pt; font-weight: 400">Software I'm proud of</p>
    <h3><a href="nanosql">NanoSQL</a></h3>
    <p>NanoSQL is a lightweight data mapper for SQLite and Rust.</p>
    <p>It is not a full-blown ORM or query builder. It does <strong>not</strong> attempt to 
    typecheck your SQL queries; it only makes sure that serialization of bind parameters and
    deserialization of result rows is type-safe. It is similar in its spirit to Dapper in the
    C#/.NET ecosystem.</p>
    <p>It <strong>does</strong>, however, provide some convenience helpers for frequently
    needed tasks, such as creating a table (and its indexes), inserting records, and finding
    or deleting rows by their <tt>PRIMARY KEY</tt>.</p>
    <p>NanoSQL is built on top of the trusty <tt>rusqlite</tt> library, and it is 100% safe
    code. We use <tt>#![forbid(unsafe_code)]</tt> to ensure this property going forward.</p>
    <h3><a href="parsel">Parsel</a></h3>
    <p>Parsel is a next-generation parser generator library for Rust, inspired by Serde. It
    allows you to focus on the high-level design of your language, without worrying about
    writing parsers by hand, or needing to tediously map low-level parse trees to high-level
    ASTs. It fully preserves source locations and spans, while also providing a means to
    seamlessly unparse ASTs into source code. No external tools required!</p>
    <p>It does so by providing <tt>#[derive]</tt> macros that automatically implement the
    <tt>syn::Parse</tt> and <tt>syn::ToTokens</tt> traits for your custom <tt>struct</tt>
    and <tt>enum</tt> types. Structs are parsed one field at a time, in sequence, while
    enums are parsed into the first variant that succeeds. ASTs are returned directly and
    in a completely automated manner. No manual mapping from the parser output to the AST
    types is necessary whatsoever. Modifying the AST automatically updates the parser.</p>
    <p>An extensive set of helper types is available for parsing common constructs, such as
    repetition, parentheses, and infix operators.</p>
  </body>
</html>
